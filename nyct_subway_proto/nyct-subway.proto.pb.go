// Code generated by protoc-gen-go.
// source: nyct-subway.proto.txt
// DO NOT EDIT!

/*
Package nyct_subway_proto is a generated protocol buffer package.

It is generated from these files:
	nyct-subway.proto.txt

It has these top-level messages:
	TripReplacementPeriod
	NyctFeedHeader
	NyctTripDescriptor
	NyctStopTimeUpdate
*/
package nyct_subway_proto

import (
	math "math"

	"github.com/golang/protobuf/proto"
	"github.com/jprobinson/gtfs/transit_realtime"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

// The direction the train is moving.
type NyctTripDescriptor_Direction int32

const (
	NyctTripDescriptor_NORTH NyctTripDescriptor_Direction = 1
	NyctTripDescriptor_EAST  NyctTripDescriptor_Direction = 2
	NyctTripDescriptor_SOUTH NyctTripDescriptor_Direction = 3
	NyctTripDescriptor_WEST  NyctTripDescriptor_Direction = 4
)

var NyctTripDescriptor_Direction_name = map[int32]string{
	1: "NORTH",
	2: "EAST",
	3: "SOUTH",
	4: "WEST",
}
var NyctTripDescriptor_Direction_value = map[string]int32{
	"NORTH": 1,
	"EAST":  2,
	"SOUTH": 3,
	"WEST":  4,
}

func (x NyctTripDescriptor_Direction) Enum() *NyctTripDescriptor_Direction {
	p := new(NyctTripDescriptor_Direction)
	*p = x
	return p
}
func (x NyctTripDescriptor_Direction) String() string {
	return proto.EnumName(NyctTripDescriptor_Direction_name, int32(x))
}
func (x *NyctTripDescriptor_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NyctTripDescriptor_Direction_value, data, "NyctTripDescriptor_Direction")
	if err != nil {
		return err
	}
	*x = NyctTripDescriptor_Direction(value)
	return nil
}

type TripReplacementPeriod struct {
	// The replacement period is for this route
	RouteId *string `protobuf:"bytes,1,opt,name=route_id" json:"route_id,omitempty"`
	// The start time is omitted, the end time is currently now + 30 minutes for
	// all routes of the A division
	ReplacementPeriod *transit_realtime.TimeRange `protobuf:"bytes,2,opt,name=replacement_period" json:"replacement_period,omitempty"`
	XXX_unrecognized  []byte                      `json:"-"`
}

func (m *TripReplacementPeriod) Reset()         { *m = TripReplacementPeriod{} }
func (m *TripReplacementPeriod) String() string { return proto.CompactTextString(m) }
func (*TripReplacementPeriod) ProtoMessage()    {}

func (m *TripReplacementPeriod) GetRouteId() string {
	if m != nil && m.RouteId != nil {
		return *m.RouteId
	}
	return ""
}

func (m *TripReplacementPeriod) GetReplacementPeriod() *transit_realtime.TimeRange {
	if m != nil {
		return m.ReplacementPeriod
	}
	return nil
}

// NYCT Subway extensions for the feed header
type NyctFeedHeader struct {
	// Version of the NYCT Subway extensions
	// The current version is 1.0
	NyctSubwayVersion *string `protobuf:"bytes,1,req,name=nyct_subway_version" json:"nyct_subway_version,omitempty"`
	// For the NYCT Subway, the GTFS-realtime feed replaces any scheduled
	// trip within the trip_replacement_period.
	// This feed is a full dataset, it contains all trips starting
	// in the trip_replacement_period. If a trip from the static GTFS is not
	// found in the GTFS-realtime feed, it should be considered as cancelled.
	// The replacement period can be different for each route, so here is
	// a list of the routes where the trips in the feed replace all
	// scheduled trips within the replacement period.
	TripReplacementPeriod []*TripReplacementPeriod `protobuf:"bytes,2,rep,name=trip_replacement_period" json:"trip_replacement_period,omitempty"`
	XXX_unrecognized      []byte                   `json:"-"`
}

func (m *NyctFeedHeader) Reset()         { *m = NyctFeedHeader{} }
func (m *NyctFeedHeader) String() string { return proto.CompactTextString(m) }
func (*NyctFeedHeader) ProtoMessage()    {}

func (m *NyctFeedHeader) GetNyctSubwayVersion() string {
	if m != nil && m.NyctSubwayVersion != nil {
		return *m.NyctSubwayVersion
	}
	return ""
}

func (m *NyctFeedHeader) GetTripReplacementPeriod() []*TripReplacementPeriod {
	if m != nil {
		return m.TripReplacementPeriod
	}
	return nil
}

// NYCT Subway extensions for the trip descriptor
type NyctTripDescriptor struct {
	// The nyct_train_id is meant for internal use only. It provides an
	// easy way to associated GTFS-realtime trip identifiers with NYCT rail
	// operations identifier
	//
	// The ATS office system assigns unique train identification (Train ID) to
	// each train operating within or ready to enter the mainline of the
	// monitored territory. An example of this is 06 0123+ PEL/BBR and is decoded
	// as follows:
	//
	// The first character represents the trip type designator. 0 identifies a
	// scheduled revenue trip. Other revenue trip values that are a result of a
	// change to the base schedule include; [= reroute], [/ skip stop], [$ turn
	// train] also known as shortly lined service.
	//
	// The second character 6 represents the trip line i.e. number 6 train The
	// third set of characters identify the decoded origin time. The last
	// character may be blank "on the whole minute" or + "30 seconds"
	//
	// Note: Origin times will not change when there is a trip type change.  This
	// is followed by a three character "Origin Location" / "Destination
	// Location"
	TrainId *string `protobuf:"bytes,1,opt,name=train_id" json:"train_id,omitempty"`
	// This trip has been assigned to a physical train. If true, this trip is
	// already underway or most likely will depart shortly.
	//
	// Train Assignment is a function of the Automatic Train Supervision (ATS)
	// office system used by NYCT Rail Operations to monitor and track train
	// movements. ATS provides the ability to "assign" the nyct_train_id
	// attribute when a physical train is at its origin terminal. These assigned
	// trips have the is_assigned field set in the TripDescriptor.
	//
	// When a train is at a terminal but has not been given a work program it is
	// declared unassigned and is tagged as such. Unassigned trains can be moved
	// to a storage location or assigned a nyct_train_id when a determination for
	// service is made.
	IsAssigned *bool `protobuf:"varint,2,opt,name=is_assigned" json:"is_assigned,omitempty"`
	// Uptown and Bronx-bound trains are moving NORTH.
	// Times Square Shuttle to Grand Central is also northbound.
	//
	// Downtown and Brooklyn-bound trains are moving SOUTH.
	// Times Square Shuttle to Times Square is also southbound.
	//
	// EAST and WEST are not used currently.
	Direction        *NyctTripDescriptor_Direction `protobuf:"varint,3,opt,name=direction,enum=NyctTripDescriptor_Direction" json:"direction,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *NyctTripDescriptor) Reset()         { *m = NyctTripDescriptor{} }
func (m *NyctTripDescriptor) String() string { return proto.CompactTextString(m) }
func (*NyctTripDescriptor) ProtoMessage()    {}

func (m *NyctTripDescriptor) GetTrainId() string {
	if m != nil && m.TrainId != nil {
		return *m.TrainId
	}
	return ""
}

func (m *NyctTripDescriptor) GetIsAssigned() bool {
	if m != nil && m.IsAssigned != nil {
		return *m.IsAssigned
	}
	return false
}

func (m *NyctTripDescriptor) GetDirection() NyctTripDescriptor_Direction {
	if m != nil && m.Direction != nil {
		return *m.Direction
	}
	return NyctTripDescriptor_NORTH
}

// NYCT Subway extensions for the stop time update
type NyctStopTimeUpdate struct {
	// Provides the planned station arrival track. The following is the Manhattan
	// track configurations:
	// 1: southbound local
	// 2: southbound express
	// 3: northbound express
	// 4: northbound local
	//
	// In the Bronx (except Dyre Ave line)
	// M: bi-directional express (in the AM express to Manhattan, in the PM
	// express away).
	//
	// The Dyre Ave line is configured:
	// 1: southbound
	// 2: northbound
	// 3: bi-directional
	ScheduledTrack *string `protobuf:"bytes,1,opt,name=scheduled_track" json:"scheduled_track,omitempty"`
	// This is the actual track that the train is operating on and can be used to
	// determine if a train is operating according to its current schedule
	// (plan).
	//
	// The actual track is known only shortly before the train reaches a station,
	// typically not before it leaves the previous station. Therefore, the NYCT
	// feed sets this field only for the first station of the remaining trip.
	//
	// Different actual and scheduled track is the result of manually rerouting a
	// train off it scheduled path.  When this occurs, prediction data may become
	// unreliable since the train is no longer operating in accordance to its
	// schedule.  The rules engine for the 'countdown' clocks will remove this
	// train from all schedule stations.
	ActualTrack      *string `protobuf:"bytes,2,opt,name=actual_track" json:"actual_track,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NyctStopTimeUpdate) Reset()         { *m = NyctStopTimeUpdate{} }
func (m *NyctStopTimeUpdate) String() string { return proto.CompactTextString(m) }
func (*NyctStopTimeUpdate) ProtoMessage()    {}

func (m *NyctStopTimeUpdate) GetScheduledTrack() string {
	if m != nil && m.ScheduledTrack != nil {
		return *m.ScheduledTrack
	}
	return ""
}

func (m *NyctStopTimeUpdate) GetActualTrack() string {
	if m != nil && m.ActualTrack != nil {
		return *m.ActualTrack
	}
	return ""
}

var E_NyctFeedHeader = &proto.ExtensionDesc{
	ExtendedType:  (*transit_realtime.FeedHeader)(nil),
	ExtensionType: (*NyctFeedHeader)(nil),
	Field:         1001,
	Name:          "nyct_feed_header",
	Tag:           "bytes,1001,opt,name=nyct_feed_header",
}

var E_NyctTripDescriptor = &proto.ExtensionDesc{
	ExtendedType:  (*transit_realtime.TripDescriptor)(nil),
	ExtensionType: (*NyctTripDescriptor)(nil),
	Field:         1001,
	Name:          "nyct_trip_descriptor",
	Tag:           "bytes,1001,opt,name=nyct_trip_descriptor",
}

var E_NyctStopTimeUpdate = &proto.ExtensionDesc{
	ExtendedType:  (*transit_realtime.TripUpdate_StopTimeUpdate)(nil),
	ExtensionType: (*NyctStopTimeUpdate)(nil),
	Field:         1001,
	Name:          "nyct_stop_time_update",
	Tag:           "bytes,1001,opt,name=nyct_stop_time_update",
}

func init() {
	proto.RegisterEnum("NyctTripDescriptor_Direction", NyctTripDescriptor_Direction_name, NyctTripDescriptor_Direction_value)
	proto.RegisterExtension(E_NyctFeedHeader)
	proto.RegisterExtension(E_NyctTripDescriptor)
	proto.RegisterExtension(E_NyctStopTimeUpdate)
}
